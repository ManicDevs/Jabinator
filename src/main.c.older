#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <loudmouth/loudmouth.h>

static LmSSLResponse ssl_func(LmSSL *ssl, LmSSLStatus status, gpointer user_data)
{
    return LM_SSL_RESPONSE_CONTINUE;
}

static void print_usage(const gchar *exec_name)
{
    g_print("Usage: %s <public-server> <connect-server> <connect-port> [ssl?]\n", exec_name);
}

static void rand_str(char *dest, size_t length)
{
    const char charset[] =	"0123456789"
							"abcdefghijklmnopqrstuvwxyz";

    while(length-- != 0)
    {
        size_t index = (double)rand() / RAND_MAX * (sizeof charset - 1);
        *dest++ = charset[index];
    }
    
    *dest = '\0';
}

int main(int argc, char *argv[])
{
	char randstr[6] = "";
    const gchar	*public_server = NULL;
    const gchar	*connect_server = NULL;
    const gchar *connect_port = NULL;
    const gchar *username = NULL;
    const gchar *password = NULL;
    gchar *jid = NULL;
    
    GError *error = NULL;
    
	gboolean			use_ssl = FALSE;
    LmConnection		*connection;
    LmMessage     		*m, *reply;
	LmMessageNode		*query, *node;

    if(argc < 4)
    {
        print_usage(argv[0]);
        return -1;
    }
	
	if(argc == 5)
		use_ssl = 1;
	
	srand(time(NULL));
	rand_str(randstr, 6);

    public_server = argv[1];
    connect_server = argv[2];
    connect_port = argv[3];
    username = password = randstr;

	printf("Public-Server: %s\nConnect-Server: %s\nUser: %s\nPass: %s\n", 
		public_server, connect_server, username, password);
	
	connection = lm_connection_new(connect_server);
	jid = g_strdup_printf("%s@%s", username, public_server);
	lm_connection_set_jid(connection, jid);
	g_free(jid);
	
	if(use_ssl)
	{
		LmSSL *ssl;
		
		if(!lm_ssl_is_supported())
		{
			g_print("This loudmouth installation doesn't support SSL\n");
			return -1;
		}
		
		g_print("Setting SSL\n");
		ssl = lm_ssl_new(NULL, ssl_func, NULL, NULL);
		lm_connection_set_ssl(connection, ssl);
		lm_ssl_unref(ssl);
	}
	
	lm_connection_set_port(connection, strtol(connect_port, (char **) NULL, 10));
	
	if(!lm_connection_open_and_block(connection, &error))
		g_error("Failed to open: %s\n", error->message);
	
	m = lm_message_new_with_sub_type(NULL, LM_MESSAGE_TYPE_IQ, LM_MESSAGE_SUB_TYPE_SET);	
	query = lm_message_node_add_child(m->node, "query", NULL);	
	lm_message_node_set_attributes(query, "xmlns", "jabber:iq:register", NULL);
	lm_message_node_add_child(query, "username", username);
	lm_message_node_add_child(query, "password", password);
	
	reply = lm_connection_send_with_reply_and_block(connection, m, &error);
	if(!reply)
		g_error("Failed to send registration request: %s\n", error->message);
	
	switch(lm_message_get_sub_type(reply))
	{
		case LM_MESSAGE_SUB_TYPE_RESULT:
			g_print("Succeeded in registering account '%s@%s'\n", username, public_server);
		break;
		
		case LM_MESSAGE_SUB_TYPE_ERROR:
		default:
			g_print("Failed to register account '%s@%s' due to: ", username, public_server);
			
			node = lm_message_node_find_child(reply->node, "error");
			if(node)
				g_print("%s\n", lm_message_node_get_value(node));
			else
				g_print("Unknown error\n");
		break;
	}
	
	lm_connection_close(connection, NULL);
	
    return 0;
}
